{
  "name": "reparse",
  "description": "A parser combinator library like Parsec.",
  "version": "0.1.2",
  "author": {
    "name": "Ben Weaver",
    "email": "ben@orangesoda.net"
  },
  "contributors": [],
  "dependencies": {},
  "keywords": [
    "parse",
    "parser",
    "combinator",
    "regexp",
    "regular",
    "expression"
  ],
  "directories": {
    "lib": "./lib"
  },
  "main": "./lib/reparse",
  "scripts": {},
  "bin": {},
  "engines": {
    "node": ">= 0.1.103"
  },
  "readme": "# ReParse #\n\nReParse is a parser combinator library for Javascript like Haskell's\n[Parsec](http://legacy.cs.uu.nl/daan/parsec.html).\n\n## Installation ##\n\nDownload `lib/reparse.js` and add it to your project or use `npm\ninstall reparse`.\n\n## API ##\n\nTo use ReParse, construct a `new ReParse(input)` object, then call the\n`.start()` method, passing it the top-level production of your\ngrammar.  Each production may be a RegExp or a function.\n\nA RegExp will produce the first captured group or the entire value it\nmatched if there are no groups.  Functions are called with `this`\nbound to the parser.  They take no arguments.  A function should\ninvoke one or more parser methods, optionally transforming the results\ninto an appropriate return value.\n\nHere is a grammar for a subset of JSON that supports arrays and\npositive integers.  See `examples/json.js` for a more complete\nexample:\n\n    // e.g: parse(\"[1, [2]]\")\n    var ReParse = require('reparse');\n\n    function parse(data) {\n      return (new ReParse(data, true)).start(value);\n    }\n\n    function value() {\n      return this.choice(number, array);\n    }\n\n    function array() {\n      return this.between(/^\\[/, /^\\]/, elements);\n    }\n\n    function elements() {\n      return this.sepBy(value, /^,/);\n    }\n\n    function number() {\n      return parseInt(this.match(/^\\d+/));\n    }\n\nReParse indicates failure internally using exceptions, so it's safe to\nuse the result of any production immediately without checking for an\nerror state.\n\n### ReParse(input, [ignorews]) ###\n\nCreate a new parser for an `input` string.  If `ignorews` is `true`,\nskip whitespace before and after each production.\n\n#### .start(method) ####\n\nReturn the value produced by `method`.  All input must be consumed.\n\n#### .eof() ####\n\nReturn `true` if the input is exhausted.\n\n#### .fail() ####\n\nCalling this method indicates that a production has failed; an\nexception will be raised and caught by the previous production.\n\n#### .produce(method) ####\n\nApply the production `method` to the input and return the result.\n\n#### .maybe(method) ####\n\nApply the production `method` to the input and return the result.  If\n`method` fails, restoring the input to its previous state.\n\n#### .option(method, otherwise) ####\n\nTry to produce `method`.  If it fails, restore the input and return\n`otherwise`.\n\n#### .match(regexp) ####\n\nMatch a regular expression against the input, returning the first\ncaptured group.  If no group is captured, return the matched string.\n\n#### .choice(alt1, alt2, ...) ####\n\nTry alternatives from left to right, returning the value of the first\none that's successful.\n\n#### .seq(p1, p2, ...) ####\n\nApply a sequence of productions from left to right.  They must all\nsucceed.  Return an array of capture groups (like a regular expression\nmatch would).  Index 0 is the entire matched string, index 1\ncorresponds to `p1`, etc.\n\n#### .many(method) ####\n\nReturn an array of zero or more values produced by `method`.\n\n#### .many1(method) ####\n\nReturn an array of one or more values produced by `method`.\n\n#### .between(left, right, body) ####\n\nThis is equivalent to `.seq(left, body, right)[2]`.\n\n#### .skip(method) ####\n\nIgnore zero or more instances of `method`.  Return the parser object.\n\n#### .skip1(method) ####\n\nIgnore one or more instances of `method`.  Return the parser object.\n\n#### .skipWS() ####\n\nIgnore whitespace.  Return the parser object.\n\n#### .sepBy(method, sep) ####\n\nReturn an array of zero or more values produced by `method`.  Each\nvalue is separated by `sep`.\n\n#### .sepBy1(method, sep) ####\n\nReturn an array of one or more values produced by `method`.  Each\nvalue is separated by `sep`.\n\n#### .endBy(method, end) ####\n\nThis is equivalent to `.many(method)` followed by `.option(end)`.\n\n#### .endBy1(method, end) ####\n\nThis is equivalent to `.many1(method)` followed by `.option(end)`.\n\n#### .sepEndBy(method, sep) ####\n\nReturn an array of zero or more values produced by `method`.  Each\nvalue is separated by `sep` and the entire sequence is optionally\nterminated by `sep`.\n\n#### .sepEndBy1(method, sep) ####\n\nReturn an array of one or more values produced by `method`.  Each\nvalue is separated by `sep` and the entire sequence is optionally\nterminated by `sep`.\n\n#### .chainl(method, op, [otherwise]) ####\n\nThis can be used to eliminate direct left-recursion.  Parse zero or\nmore values produced by `method` and separated by `op`.  Returns a\nvalue obtained by left associative application of functions returned\nby `op`.  If zero values are produced, return otherwise.\n\n#### .chainl1(method, op) ####\n\nLike `.chainl`, but at least one value must be produced by `method`.\nFor example, this grammar:\n\n    expr   ::= expr '+' term | term\n    term   ::= term '*' factor | factor\n\nMight be implemented like this (see `examples/calc.js`):\n\n    function expr() {\n      return this.chainl1(term, addop);\n    }\n\n    function term() {\n      return this.chainl1(factor, mulop);\n    }\n\n    function factor() {\n      ...\n    }\n\n## Compatibility ##\n\nReParse has been tested with Node.JS version `v0.1.103`.  It should\nwork in a browser if you comment out the `exports` line.\n\n## License ##\n\nCopyright (c) 2010, Ben Weaver &lt;ben@orangesoda.net&gt;\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n* Redistributions of source code must retain the above copyright\n  notice, this list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright\n  notice, this list of conditions and the following disclaimer in the\n  documentation and/or other materials provided with the distribution.\n\n* Neither the name of the <organization> nor the names of its\n  contributors may be used to endorse or promote products derived from\n  this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT\nHOLDER> BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\nEXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\nPROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\nPROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\nLIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\nNEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n",
  "readmeFilename": "README.md",
  "_id": "reparse@0.1.2",
  "dist": {
    "shasum": "b4e67a44e302f136b84b896ac2eb94afd1e52953"
  },
  "_from": "reparse@>= 0.1.2",
  "_resolved": "https://registry.npmjs.org/reparse/-/reparse-0.1.2.tgz"
}
